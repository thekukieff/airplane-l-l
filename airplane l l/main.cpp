#include <iostream>
class Base {
public:
	//объявили что в классе есть статическая переменная, НО МЫ ЕЕ НЕ СОЗДАЛИ
	//будет жить в заголовочных файлах 
	static int str;
	static void PrintHello() {
		std::cout << "Hello World\n";
		
	}
	


private:
	int c_ = 0;
};

int Base::str = 0;
//без unt не запустится. мы определили чем является str
//ТОЛЬКО В ФАЙЛАХ СРР
int main() {
	//static внутри функции меняет место хранения переменной перемещает ее из стека вызовов в глобальные переменные 
	//static если применен к свободным функциям или глобальным переменным, то запрещает их вызов из сторонних кодовых файлов
	//static примененное к методам или полям класса позволяет работать с данными полями и классами без создания объектов 
	//Статистические методы доступны для работы как от имени объектов класса, так и без них при обращении через имя класса
	// 
	//Правило работв статических методов{
	// Их можно вызвать в любой момент работы программы даже если объекта класса нет под рукой
	// 
	// Доступносьт  для использования зависит от категории пользования(public, private, protected)
	// 
	// В теле статического метода можо вызывать только другие статические методы класса и обращаться только к статическим полям своего класса.
	// 
	// на работу с внешними элементами(аргументами, глобальными переменными, внешними классами и функциями) ограничений нет. 
 	// 
	// 
	// } 
	//
	// От наследника можно использовать статическую функцию
	// типы наследований
	// 
	//НАСЛЕДОВАНИЕМ КОТОРОЕ ИСПОЛЬЗУЕТСЯ В ПРОЕКТАХ ПО УМОЛЧАНИЮ ЯВЛЯЕТСЯ ПУБЛИЧНОЕ. Оно позволяет включать полиморфизм
	// и именно поэтому чаще всего используется.
	// Если при наследованм не указать тип  то по умолчанию компилятор считает приватным
	// 
	// при приватном наследовании  меняется доступность родительских компонентов переходящих в класс наследник и теряется возможность применять полиморфизм
	// 
	// при защищенном наследовании те же проблемы но изменение доступа к родительским полчм и методам происходит по другим правилам
	// как было в базовом классе				тип наследования
	// base_acceess|public		|protected		|private
	// public	   |public		|protected		|private
	// protected   |protexcted	|protected		|private
	// private	   |unreach		|unreach		|unreach
	// 
	// было -> что стало
	// unreach = недоступен


	Base::PrintHello();

	Base BLYA;
	BLYA.PrintHello();

	return 0;
}